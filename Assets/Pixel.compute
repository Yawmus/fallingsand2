// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ApplyPhysicsAndDraw

int width;
int height;
int debug;

RWStructuredBuffer<int> grid;
RWStructuredBuffer<int> debugVars;
RWStructuredBuffer<float4> frameColor;

uint rng_state;

uint rand_lcg()
{
	rng_state = 1664525 * rng_state + 1013904223;
	return rng_state;
}

uint rand_xorshift()
{
	rng_state ^= (rng_state << 13);
	rng_state ^= (rng_state >> 17);
	rng_state ^= (rng_state << 5);
	return rng_state;
}

[numthreads(64,1,1)]
void ApplyPhysicsAndDraw(uint3 id : SV_DispatchThreadID)
{
	int prop = grid[id.x];

	if (prop == 0)
	{
		return;
	}


	int x = (int)(id.x % width);
	int y = (int)(id.x / width);

	grid[width * y + x] = 0;
	 
	if((x == 0) || (y == 0) || (x >= (width - 1)) || (y >= (height - 1))) // Don't calc edges
	{
		frameColor[width * y + x] = float4(0, 1, 1, 1);
		return;
	}
	
	// Blocked adjacent (assuming all non-zero)
	int tTaken = grid[width * (y + 1) + x] > 0;
	int bTaken = grid[width * (y - 1) + x] > 0;
	int lTaken = grid[width * (y) + x - 1] > 0;
	int rTaken = grid[width * (y) + x + 1] > 0;
	int tlTaken = grid[width * (y + 1) + x - 1] > 0;
	int trTaken = grid[width * (y + 1) + x + 1] > 0;
	int blTaken = grid[width * (y - 1) + x - 1] > 0;
	int brTaken = grid[width * (y - 1) + x + 1] > 0;
	int bsTaken = (blTaken + brTaken) == 2;

	int moveX = 1;
	int moveY = 0;


	/*
	l = (blTaken + lTaken) == 0;  // If 1, can move left
	l *= -1;
	r = (brTaken + rTaken) == 0;  // If 1, can move right
	int moveX1 = l + r;
	int moveY1 = -step(0.0, bTaken * -1); // Calc moveY
	*/

	debugVars[id.x] = lTaken;

	grid[id.x] = 0;

	x += moveX;
	y += moveY;

	grid[width * y + x] = prop;








	// ************************
	// Getting character
	// ************************
	float4 color = float4(0, 0, 0, 0);

	// Type of particle
	color += (prop == 0) * float4(0, 0, 0, 1);
	color += lerp(0, 1, (prop & (256 + 512 + 1024)) == 256) * float4(1, .99f, .86f, 1);
	color += lerp(0, 1, (prop & (256 + 512 + 1024)) == 512) * float4(.1f, .1f, 1, 1);
	color += lerp(0, 1, (prop & (256 + 512 + 1024)) == 768) * float4(.82f, 0, .11f, 1);
	color += lerp(0, 1, (prop & (256 + 512 + 1024)) == 1024) * float4(1, 0, 1, 1);


	// ************************
	// Getting debug information
	// ************************
	if (debug && debugVars[id.x])
	{
		color = float4(1, .55, 0, 1);
	}

	// ************************
	// Drawing to screen
	// ************************
	frameColor[width * y + x] = color;
}